<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mindmap nâng cao với bàn phím và nhiều hình dạng</title>
<style>
  body { font-family: Arial, sans-serif; margin: 10px; user-select: none; }
  #toolbar {
    margin-bottom: 10px;
  }
  button {
    margin-right: 6px;
    margin-bottom: 6px;
  }
  #canvas {
    border: 1px solid #ccc;
    background: #fefefe;
    cursor: grab;
  }
  #exportArea {
    width: 100%;
    height: 100px;
    margin-top: 10px;
    font-family: monospace;
  }
  #colorPickers {
    margin-top: 10px;
    display: flex;
    gap: 12px;
    align-items: center;
  }
  #colorPickers label {
    font-size: 14px;
  }
  #colorPickers input[type=color] {
    cursor: pointer;
    width: 40px;
    height: 25px;
    border: none;
  }
</style>
</head>
<body>

<h2>Mindmap nâng cao với bàn phím và nhiều hình dạng</h2>

<div id="toolbar">
  <button id="addNodeBtn">Thêm nút</button>
  <select id="shapeSelector" title="Chọn hình dạng nút">
    <option value="circle">Hình tròn</option>
    <option value="rect">Hình chữ nhật</option>
    <option value="ellipse">Hình elip</option>
    <option value="diamond">Hình thoi</option>
  </select>
  <button id="deleteNodeBtn" disabled>Xóa nút</button>
  <button id="deleteLinkBtn" disabled>Xóa liên kết</button>
  <button id="autoLayoutBtn">Tự động sắp xếp</button>
  <button id="undoBtn" disabled>Undo</button>
  <button id="redoBtn" disabled>Redo</button>
  <button id="exportBtn">Xuất dữ liệu JSON</button>
  <button id="importBtn">Tải dữ liệu JSON</button>
  <button id="exportPngBtn">Xuất ảnh PNG</button>
  <button id="copyNodeBtn" disabled>Copy nút</button>
  <button id="pasteNodeBtn" disabled>Paste nút</button>
  <input type="file" id="fileInput" style="display:none" accept=".json" />
</div>

<div id="colorPickers">
  <label for="fillColorPicker">Màu nền nút:</label>
  <input type="color" id="fillColorPicker" value="#ffffff" />
  <label for="strokeColorPicker">Màu viền nút:</label>
  <input type="color" id="strokeColorPicker" value="#333333" />
</div>

<canvas id="canvas" width="900" height="600" tabindex="0"></canvas>
<textarea id="exportArea" placeholder="Dữ liệu JSON xuất ra sẽ hiện ở đây" readonly></textarea>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // Toolbar buttons
  const addNodeBtn = document.getElementById('addNodeBtn');
  const deleteNodeBtn = document.getElementById('deleteNodeBtn');
  const deleteLinkBtn = document.getElementById('deleteLinkBtn');
  const autoLayoutBtn = document.getElementById('autoLayoutBtn');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const exportBtn = document.getElementById('exportBtn');
  const importBtn = document.getElementById('importBtn');
  const exportPngBtn = document.getElementById('exportPngBtn');
  const copyNodeBtn = document.getElementById('copyNodeBtn');
  const pasteNodeBtn = document.getElementById('pasteNodeBtn');
  const fileInput = document.getElementById('fileInput');
  const exportArea = document.getElementById('exportArea');
  const shapeSelector = document.getElementById('shapeSelector');
  const fillColorPicker = document.getElementById('fillColorPicker');
  const strokeColorPicker = document.getElementById('strokeColorPicker');

  // Data structures
  let nodes = [];
  let links = [];

  // History stacks for undo/redo
  let history = [];
  let historyIndex = -1;

  // Viewport transform
  let offsetX = 0;
  let offsetY = 0;
  let scale = 1;

  // Interaction state
  let draggingNode = null;
  let dragOffsetX = 0;
  let dragOffsetY = 0;

  let draggingCanvas = false;
  let dragCanvasStartX = 0;
  let dragCanvasStartY = 0;
  let dragCanvasOffsetX = 0;
  let dragCanvasOffsetY = 0;

  let selectedNode = null;
  let selectedLink = null;
  let linkStartNode = null;

  let copiedNode = null;

  // Constants
  const NODE_RADIUS = 40;
  const NODE_WIDTH = 120;
  const NODE_HEIGHT = 70;

  // Classes
  class Node {
    constructor(id, text, x, y, shape = 'circle', fillColor = '#ffffff', strokeColor = '#333333') {
      this.id = id;
      this.text = text;
      this.x = x;
      this.y = y;
      this.shape = shape; // circle, rect, ellipse, diamond
      this.fillColor = fillColor;
      this.strokeColor = strokeColor;
      this.radius = NODE_RADIUS;
      this.width = NODE_WIDTH;
      this.height = NODE_HEIGHT;
    }

    isPointInside(px, py) {
      const dx = px - this.x;
      const dy = py - this.y;

      switch (this.shape) {
        case 'circle':
          return dx * dx + dy * dy <= this.radius * this.radius;
        case 'rect':
          return px >= this.x - this.width / 2 && px <= this.x + this.width / 2 &&
                 py >= this.y - this.height / 2 && py <= this.y + this.height / 2;
        case 'ellipse':
          // ellipse formula (dx/a)^2 + (dy/b)^2 <= 1
          return (dx*dx) / ((this.width/2)*(this.width/2)) + (dy*dy) / ((this.height/2)*(this.height/2)) <= 1;
        case 'diamond':
          // diamond shape: |dx|/(width/2) + |dy|/(height/2) <= 1
          return (Math.abs(dx) / (this.width / 2)) + (Math.abs(dy) / (this.height / 2)) <= 1;
        default:
          return false;
      }
    }
  }

  function saveHistory() {
    const state = {
      nodes: JSON.parse(JSON.stringify(nodes)),
      links: JSON.parse(JSON.stringify(links))
    };
    history = history.slice(0, historyIndex + 1);
    history.push(state);
    historyIndex++;
    updateUndoRedoButtons();
  }

  function undo() {
    if (historyIndex <= 0) return;
    historyIndex--;
    restoreState(history[historyIndex]);
    updateUndoRedoButtons();
  }

  function redo() {
    if (historyIndex >= history.length - 1) return;
    historyIndex++;
    restoreState(history[historyIndex]);
    updateUndoRedoButtons();
  }

  function restoreState(state) {
    nodes = state.nodes.map(n => new Node(
      n.id, n.text, n.x, n.y, n.shape, n.fillColor, n.strokeColor
    ));
    links = JSON.parse(JSON.stringify(state.links));
    selectedNode = null;
    selectedLink = null;
    draw();
  }

  function updateUndoRedoButtons() {
    undoBtn.disabled = historyIndex <= 0;
    redoBtn.disabled = historyIndex >= history.length - 1;
  }

  function toWorld(x, y) {
    return {
      x: (x - offsetX) / scale,
      y: (y - offsetY) / scale
    };
  }

  function toScreen(x, y) {
    return {
      x: x * scale + offsetX,
      y: y * scale + offsetY
    };
  }

  function drawNodeShape(node, x, y, radius, width, height) {
    ctx.beginPath();
    switch(node.shape) {
      case 'circle':
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        break;
      case 'rect':
        ctx.rect(x - width/2, y - height/2, width, height);
        break;
      case 'ellipse':
        ctx.ellipse(x, y, width/2, height/2, 0, 0, Math.PI * 2);
        break;
      case 'diamond':
        ctx.moveTo(x, y - height/2);
        ctx.lineTo(x + width/2, y);
        ctx.lineTo(x, y + height/2);
        ctx.lineTo(x - width/2, y);
        ctx.closePath();
        break;
      default:
        ctx.arc(x, y, radius, 0, Math.PI * 2);
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw links
    ctx.lineWidth = 2;
    links.forEach(link => {
      const from = nodes.find(n => n.id === link.from);
      const to = nodes.find(n => n.id === link.to);
      if (from && to) {
        const fromScreen = toScreen(from.x, from.y);
        const toScreenPos = toScreen(to.x, to.y);
        ctx.strokeStyle = (selectedLink === link) ? '#e74c3c' : '#555';
        ctx.beginPath();
        ctx.moveTo(fromScreen.x, fromScreen.y);
        ctx.lineTo(toScreenPos.x, toScreenPos.y);
        ctx.stroke();
      }
    });

    // Draw nodes
    nodes.forEach(node => {
      const screenPos = toScreen(node.x, node.y);
      ctx.fillStyle = node.fillColor;
      ctx.strokeStyle = (node === selectedNode) ? '#e67e22' : node.strokeColor;
      ctx.lineWidth = 3;
      ctx.shadowColor = 'rgba(0,0,0,0.15)';
      ctx.shadowBlur = 6;
      ctx.shadowOffsetX = 2;
      ctx.shadowOffsetY = 2;

      drawNodeShape(node, screenPos.x, screenPos.y, node.radius * scale, node.width * scale, node.height * scale);
      ctx.fill();
      ctx.shadowColor = 'transparent';
      ctx.stroke();

      // Text
      ctx.fillStyle = '#000';
      ctx.font = `${14 * scale}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      wrapText(ctx, node.text, screenPos.x, screenPos.y, (node.width - 20) * scale, 18 * scale);
    });
  }

  function wrapText(context, text, x, y, maxWidth, lineHeight) {
    const words = text.split(' ');
    let line = '';
    const lines = [];
    for (let i = 0; i < words.length; i++) {
      const testLine = line + words[i] + ' ';
      const metrics = context.measureText(testLine);
      if (metrics.width > maxWidth && i > 0) {
        lines.push(line);
        line = words[i] + ' ';
      } else {
        line = testLine;
      }
    }
    lines.push(line);

    const totalHeight = lines.length * lineHeight;
    let startY = y - totalHeight / 2 + lineHeight / 2;

    for (let i = 0; i < lines.length; i++) {
      context.fillText(lines[i].trim(), x, startY + i * lineHeight);
    }
  }

  function addNode() {
    const text = prompt('Nhập nội dung cho nút:');
    if (!text) return;
    const centerX = (canvas.width / 2 - offsetX) / scale;
    const centerY = (canvas.height / 2 - offsetY) / scale;
    const id = Date.now().toString();
    const shape = shapeSelector.value;
    const fillColor = fillColorPicker.value;
    const strokeColor = strokeColorPicker.value;
    nodes.push(new Node(id, text, centerX, centerY, shape, fillColor, strokeColor));
    saveHistory();
    draw();
  }

  function getNodeAtPos(screenX, screenY) {
    const worldPos = toWorld(screenX, screenY);
    return nodes.find(node => node.isPointInside(worldPos.x, worldPos.y));
  }

  function getLinkAtPos(screenX, screenY) {
    const worldPos = toWorld(screenX, screenY);
    const tolerance = 10 / scale;
    for (const link of links) {
      const from = nodes.find(n => n.id === link.from);
      const to = nodes.find(n => n.id === link.to);
      if (!from || !to) continue;
      if (pointNearLine(worldPos, from, to, tolerance)) {
        return link;
      }
    }
    return null;
  }

  function pointNearLine(p, a, b, tol) {
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const lengthSq = dx * dx + dy * dy;
    if (lengthSq === 0) return false;
    let t = ((p.x - a.x) * dx + (p.y - a.y) * dy) / lengthSq;
    t = Math.max(0, Math.min(1, t));
    const projX = a.x + t * dx;
    const projY = a.y + t * dy;
    const distSq = (p.x - projX) ** 2 + (p.y - projY) ** 2;
    return distSq <= tol * tol;
  }

  canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
      draggingCanvas = true;
      dragCanvasStartX = x;
      dragCanvasStartY = y;
      dragCanvasOffsetX = offsetX;
      dragCanvasOffsetY = offsetY;
      canvas.style.cursor = 'grabbing';
      return;
    }

    if (e.ctrlKey && e.button === 0) {
      const node = getNodeAtPos(x, y);
      if (!node) return;
      if (!linkStartNode) {
        linkStartNode = node;
        alert('Chọn nút thứ hai (Ctrl + click) để nối liên kết');
      } else if (linkStartNode.id !== node.id) {
        const exists = links.some(l => 
          (l.from === linkStartNode.id && l.to === node.id) ||
          (l.from === node.id && l.to === linkStartNode.id)
        );
        if (!exists) {
          links.push({ from: linkStartNode.id, to: node.id });
          saveHistory();
        }
        linkStartNode = null;
        draw();
      }
      return;
    }

    const node = getNodeAtPos(x, y);
    if (node) {
      draggingNode = node;
      selectedNode = node;
      selectedLink = null;
      dragOffsetX = toWorld(x, y).x - node.x;
      dragOffsetY = toWorld(x, y).y - node.y;
      deleteNodeBtn.disabled = false;
      deleteLinkBtn.disabled = true;
      copyNodeBtn.disabled = false;
      draw();
      return;
    }

    const link = getLinkAtPos(x, y);
    if (link) {
      selectedLink = link;
      selectedNode = null;
      deleteLinkBtn.disabled = false;
      deleteNodeBtn.disabled = true;
      copyNodeBtn.disabled = true;
      draw();
      return;
    }

    selectedNode = null;
    selectedLink = null;
    deleteNodeBtn.disabled = true;
    deleteLinkBtn.disabled = true;
    copyNodeBtn.disabled = true;
    draw();
  });

  canvas.addEventListener('mousemove', (e) => {
    if (draggingNode) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const worldPos = toWorld(x, y);
      draggingNode.x = worldPos.x - dragOffsetX;
      draggingNode.y = worldPos.y - dragOffsetY;
      draw();
    } else if (draggingCanvas) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      offsetX = dragCanvasOffsetX + (x - dragCanvasStartX);
      offsetY = dragCanvasOffsetY + (y - dragCanvasStartY);
      draw();
    }
  });

  canvas.addEventListener('mouseup', (e) => {
    if (draggingNode) {
      draggingNode = null;
      saveHistory();
    }
    if (draggingCanvas) {
      draggingCanvas = false;
      canvas.style.cursor = 'grab';
    }
  });

  canvas.addEventListener('mouseleave', () => {
    if (draggingNode) {
      draggingNode = null;
      saveHistory();
    }
    if (draggingCanvas) {
      draggingCanvas = false;
      canvas.style.cursor = 'grab';
    }
  });

  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const wheel = e.deltaY < 0 ? 1.1 : 0.9;

    const worldPosBefore = toWorld(mouseX, mouseY);
    scale *= wheel;
    scale = Math.min(Math.max(scale, 0.2), 3);
    const worldPosAfter = toWorld(mouseX, mouseY);

    offsetX += (worldPosAfter.x - worldPosBefore.x) * scale;
    offsetY += (worldPosAfter.y - worldPosBefore.y) * scale;

    draw();
  });

  canvas.addEventListener('dblclick', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const node = getNodeAtPos(x, y);
    if (!node) return;
    const newText = prompt('Chỉnh sửa nội dung nút:', node.text);
    if (newText !== null) {
      node.text = newText.trim() || node.text;
      saveHistory();
      draw();
    }
  });

  // Toolbar buttons events
  addNodeBtn.onclick = addNode;

  deleteNodeBtn.onclick = () => {
    if (!selectedNode) return;
    links = links.filter(l => l.from !== selectedNode.id && l.to !== selectedNode.id);
    nodes = nodes.filter(n => n.id !== selectedNode.id);
    selectedNode = null;
    deleteNodeBtn.disabled = true;
    copyNodeBtn.disabled = true;
    saveHistory();
    draw();
  };

  deleteLinkBtn.onclick = () => {
    if (!selectedLink) return;
    links = links.filter(l => l !== selectedLink);
    selectedLink = null;
    deleteLinkBtn.disabled = true;
    saveHistory();
    draw();
  };

  undoBtn.onclick = undo;
  redoBtn.onclick = redo;

  exportBtn.onclick = () => {
    const data = { nodes, links };
    const jsonStr = JSON.stringify(data, null, 2);
    exportArea.value = jsonStr;
  };

  importBtn.onclick = () => {
    fileInput.click();
  };

  fileInput.onchange = e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = event => {
      try {
        const data = JSON.parse(event.target.result);
        if (data.nodes && data.links) {
          nodes = data.nodes.map(n => new Node(
            n.id, n.text, n.x, n.y, n.shape, n.fillColor, n.strokeColor
          ));
          links = data.links;
          selectedNode = null;
          selectedLink = null;
          offsetX = 0;
          offsetY = 0;
          scale = 1;
          saveHistory();
          draw();
          alert('Dữ liệu đã được tải thành công!');
        } else {
          alert('File JSON không hợp lệ!');
        }
      } catch (err) {
        alert('Lỗi đọc file JSON!');
      }
    };
    reader.readAsText(file);
    fileInput.value = '';
  };

  exportPngBtn.onclick = () => {
    const dataURL = canvas.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = dataURL;
    a.download = 'mindmap.png';
    a.click();
  };

  copyNodeBtn.onclick = () => {
    if (!selectedNode) return;
    copiedNode = JSON.parse(JSON.stringify(selectedNode));
    pasteNodeBtn.disabled = false;
  };

  pasteNodeBtn.onclick = () => {
    if (!copiedNode) return;
    // Offset pasted node to avoid overlap
    const newId = Date.now().toString();
    const offsetPos = 40 / scale;
    const newNode = new Node(
      newId,
      copiedNode.text,
      copiedNode.x + offsetPos,
      copiedNode.y + offsetPos,
      copiedNode.shape,
      copiedNode.fillColor,
      copiedNode.strokeColor
    );
    nodes.push(newNode);
    selectedNode = newNode;
    deleteNodeBtn.disabled = false;
    copyNodeBtn.disabled = false;
    saveHistory();
    draw();
  };

  autoLayoutBtn.onclick = () => {
    const incoming = {};
    nodes.forEach(n => incoming[n.id] = 0);
    links.forEach(l => incoming[l.to] = (incoming[l.to] || 0) + 1);
    const roots = nodes.filter(n => incoming[n.id] === 0);
    if (roots.length === 0) {
      alert('Không tìm thấy nút gốc để tự động sắp xếp!');
      return;
    }
    const levelGap = 120;
    const siblingGap = 150;

    let currentX = 0;

    function layoutSubtree(node, depth) {
      node.y = depth * levelGap;
      const children = links.filter(l => l.from === node.id).map(l => nodes.find(n => n.id === l.to));
      if (children.length === 0) {
        node.x = currentX;
        currentX += siblingGap;
        return [node.x, node.x];
      }
      let minX = Infinity, maxX = -Infinity;
      children.forEach(child => {
        const [childMin, childMax] = layoutSubtree(child, depth + 1);
        minX = Math.min(minX, childMin);
        maxX = Math.max(maxX, childMax);
      });
      node.x = (minX + maxX) / 2;
      return [minX, maxX];
    }

    roots.forEach(root => layoutSubtree(root, 0));

    saveHistory();
    draw();
  };

  // Keyboard support
  canvas.addEventListener('keydown', (e) => {
    if (document.activeElement !== canvas) return;

    switch(e.key) {
      case 'Delete':
      case 'Backspace':
        if (selectedNode) {
          deleteNodeBtn.click();
        } else if (selectedLink) {
          deleteLinkBtn.click();
        }
        e.preventDefault();
        break;
      case 'ArrowUp':
      case 'ArrowDown':
      case 'ArrowLeft':
      case 'ArrowRight':
        if (selectedNode) {
          let step = e.shiftKey ? 10 / scale : 1 / scale;
          switch(e.key) {
            case 'ArrowUp': selectedNode.y -= step; break;
            case 'ArrowDown': selectedNode.y += step; break;
            case 'ArrowLeft': selectedNode.x -= step; break;
            case 'ArrowRight': selectedNode.x += step; break;
          }
          saveHistory();
          draw();
          e.preventDefault();
        }
        break;
      case 'z':
      case 'Z':
        if (e.ctrlKey || e.metaKey) {
          if (e.shiftKey) {
            redoBtn.click();
          } else {
            undoBtn.click();
          }
          e.preventDefault();
        }
        break;
      case 'c':
      case 'C':
        if ((e.ctrlKey || e.metaKey) && selectedNode) {
          copyNodeBtn.click();
          e.preventDefault();
        }
        break;
      case 'v':
      case 'V':
        if ((e.ctrlKey || e.metaKey) && !pasteNodeBtn.disabled) {
          pasteNodeBtn.click();
          e.preventDefault();
        }
        break;
    }
  });

  // Focus canvas for keyboard support
  canvas.tabIndex = 0;

  // Initialize history and draw
  saveHistory();
  draw();

  // Instructions console log
  console.log(`Hướng dẫn sử dụng:
- Thêm nút: nút "Thêm nút"
- Chọn hình dạng, màu nền, màu viền trước khi thêm
- Kéo thả nút để di chuyển
- Ctrl + click 2 nút để tạo liên kết
- Chọn node/link và nhấn Delete để xóa
- Phím mũi tên để di chuyển nút (Shift + mũi tên di chuyển nhanh)
- Ctrl+Z / Ctrl+Y để Undo/Redo
- Ctrl+C / Ctrl+V để Copy/Paste nút
- Shift + click hoặc click giữa + kéo để di chuyển canvas
- Cuộn chuột để zoom
- Double click để chỉnh sửa nội dung nút
- Auto layout sắp xếp nút theo cây
- Xuất JSON, tải JSON để lưu/tiếp tục
- Xuất ảnh PNG`);

})();
</script>

</body>
</html>
