<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mindmap nâng cao kiểu Creately</title>
<style>
  html, body {
    height: 100%;
    margin: 0;
    overflow: hidden;
    font-family: Arial, sans-serif;
    user-select: none;
  }
  #toolbar {
    position: fixed;
    top: 10px;
    left: 10px;
    background: #ffffffcc;
    border-radius: 8px;
    padding: 8px 12px;
    box-shadow: 0 3px 8px rgba(0,0,0,0.2);
    z-index: 10;
    display: flex;
    gap: 8px;
    align-items: center;
  }
  #toolbar button {
    background: #1d72b8;
    border: none;
    color: white;
    padding: 6px 12px;
    font-size: 14px;
    border-radius: 4px;
    cursor: pointer;
  }
  #toolbar button:disabled {
    background: #cccccc;
    cursor: default;
  }
  #canvas {
    background: #fafafa;
    display: block;
    width: 100vw;
    height: 100vh;
    cursor: grab;
  }
  #contextMenu {
    position: fixed;
    background: white;
    border: 1px solid #ccc;
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
    border-radius: 6px;
    display: none;
    z-index: 20;
    min-width: 150px;
  }
  #contextMenu button {
    background: none;
    border: none;
    width: 100%;
    text-align: left;
    padding: 8px 12px;
    font-size: 14px;
    cursor: pointer;
  }
  #contextMenu button:hover {
    background: #1d72b8;
    color: white;
  }
  #exportArea {
    position: fixed;
    bottom: 10px;
    left: 10px;
    width: 30vw;
    height: 140px;
    font-family: monospace;
    font-size: 12px;
    padding: 6px;
    border: 1px solid #ccc;
    border-radius: 6px;
    resize: vertical;
    background: #fff;
    overflow: auto;
    z-index: 10;
  }
  #fileInput {
    display: none;
  }
</style>
</head>
<body>

<div id="toolbar">
  <button id="addNodeBtn">Thêm nút gốc</button>
  <button id="undoBtn" disabled>Undo</button>
  <button id="redoBtn" disabled>Redo</button>
  <button id="exportBtn">Xuất JSON</button>
  <button id="importBtn">Tải JSON</button>
  <button id="exportPngBtn">Xuất ảnh PNG</button>
</div>

<canvas id="canvas" tabindex="0"></canvas>
<textarea id="exportArea" placeholder="Dữ liệu JSON xuất ra sẽ hiện ở đây" readonly></textarea>
<input type="file" id="fileInput" accept=".json" />

<div id="contextMenu"></div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const toolbar = document.getElementById('toolbar');
  const addNodeBtn = document.getElementById('addNodeBtn');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const exportBtn = document.getElementById('exportBtn');
  const importBtn = document.getElementById('importBtn');
  const exportPngBtn = document.getElementById('exportPngBtn');
  const exportArea = document.getElementById('exportArea');
  const fileInput = document.getElementById('fileInput');
  const contextMenu = document.getElementById('contextMenu');

  // Resize canvas to fill window
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    draw();
  }
  window.addEventListener('resize', resize);
  resize();

  // Data structures
  let nodes = [];
  let links = [];
  let selectedNode = null;
  let selectedLink = null;
  let draggingNode = null;
  let dragOffsetX = 0;
  let dragOffsetY = 0;

  // History for undo/redo
  let history = [];
  let historyIndex = -1;
  function saveHistory() {
    const state = {
      nodes: JSON.parse(JSON.stringify(nodes)),
      links: JSON.parse(JSON.stringify(links))
    };
    history = history.slice(0, historyIndex + 1);
    history.push(state);
    historyIndex++;
    updateUndoRedoButtons();
  }
  function undo() {
    if(historyIndex <= 0) return;
    historyIndex--;
    restoreState(history[historyIndex]);
  }
  function redo() {
    if(historyIndex >= history.length - 1) return;
    historyIndex++;
    restoreState(history[historyIndex]);
  }
  function restoreState(state) {
    nodes = state.nodes;
    links = state.links;
    selectedNode = null;
    selectedLink = null;
    draggingNode = null;
    draw();
    updateUndoRedoButtons();
  }
  function updateUndoRedoButtons() {
    undoBtn.disabled = historyIndex <= 0;
    redoBtn.disabled = historyIndex >= history.length - 1;
  }

  // Viewport controls for pan and zoom
  let offsetX = 0;
  let offsetY = 0;
  let scale = 1;
  let draggingCanvas = false;
  let dragCanvasStart = null;
  let dragCanvasOffset = null;

  function toWorld(x, y) {
    return { x: (x - offsetX) / scale, y: (y - offsetY) / scale };
  }
  function toScreen(x, y) {
    return { x: x * scale + offsetX, y: y * scale + offsetY };
  }

  // Node class
  class Node {
    constructor(id, text, x, y) {
      this.id = id;
      this.text = text;
      this.x = x;
      this.y = y;
      this.radius = 50;
      this.color = '#4466ff';
      this.textColor = '#fff';
    }
    contains(px, py) {
      const dx = px - this.x;
      const dy = py - this.y;
      return dx * dx + dy * dy <= this.radius * this.radius;
    }
  }

  // Link class
  class Link {
    constructor(fromId, toId) {
      this.from = fromId;
      this.to = toId;
    }
  }

  // Draw functions
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);

    // Draw links first
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#666';
    ctx.fillStyle = '#666';
    links.forEach(link => {
      const fromNode = nodes.find(n => n.id === link.from);
      const toNode = nodes.find(n => n.id === link.to);
      if (!fromNode || !toNode) return;
      drawCurvedLink(fromNode, toNode);
    });

    // Draw nodes
    nodes.forEach(node => {
      drawNode(node);
    });

    ctx.restore();
  }

  function drawNode(node) {
    ctx.beginPath();
    ctx.fillStyle = node.color;
    ctx.strokeStyle = selectedNode === node ? '#f39c12' : '#333';
    ctx.lineWidth = selectedNode === node ? 4 : 2;
    ctx.shadowColor = 'rgba(0,0,0,0.25)';
    ctx.shadowBlur = 8;
    ctx.shadowOffsetX = 3;
    ctx.shadowOffsetY = 3;
    ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowColor = 'transparent';
    ctx.stroke();

    // Draw text
    ctx.fillStyle = node.textColor;
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    wrapText(ctx, node.text, node.x, node.y, node.radius * 1.8, 20);
  }

  function drawCurvedLink(fromNode, toNode) {
    const dx = toNode.x - fromNode.x;
    const dy = toNode.y - fromNode.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 10) return;
    // Control points for cubic Bezier curve
    const cp1x = fromNode.x + dx * 0.3;
    const cp1y = fromNode.y;
    const cp2x = fromNode.x + dx * 0.7;
    const cp2y = toNode.y;

    ctx.beginPath();
    ctx.strokeStyle = selectedLink && selectedLink.from === fromNode.id && selectedLink.to === toNode.id ? '#e74c3c' : '#666';
    ctx.lineWidth = selectedLink && selectedLink.from === fromNode.id && selectedLink.to === toNode.id ? 4 : 3;
    ctx.moveTo(fromNode.x, fromNode.y);
    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, toNode.x, toNode.y);
    ctx.stroke();

    // Draw arrowhead at end
    drawArrowhead(toNode.x, toNode.y, Math.atan2(dy, dx));
  }

  function drawArrowhead(x, y, angle) {
    const size = 10;
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-size, size / 2);
    ctx.lineTo(-size, -size / 2);
    ctx.closePath();
    ctx.fillStyle = ctx.strokeStyle;
    ctx.fill();
    ctx.restore();
  }

  // Wrap text in multiple lines inside node
  function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = text.split(' ');
    let line = '';
    let lines = [];
    for (let i=0; i<words.length; i++) {
      const testLine = line + words[i] + ' ';
      const metrics = ctx.measureText(testLine);
      if(metrics.width > maxWidth && i > 0) {
        lines.push(line);
        line = words[i] + ' ';
      } else {
        line = testLine;
      }
    }
    lines.push(line);

    const totalHeight = lines.length * lineHeight;
    let startY = y - totalHeight/2 + lineHeight/2;

    for(let i=0; i<lines.length; i++) {
      ctx.fillText(lines[i].trim(), x, startY + i * lineHeight);
    }
  }

  // Event handlers
  let lastMousePos = { x: 0, y: 0 };
  let isDragging = false;

  canvas.addEventListener('mousedown', e => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    lastMousePos = { x: mouseX, y: mouseY };

    if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
      // Pan mode
      draggingCanvas = true;
      dragCanvasStart = { x: mouseX, y: mouseY };
      dragCanvasOffset = { x: offsetX, y: offsetY };
      canvas.style.cursor = 'grabbing';
      return;
    }

    const worldPos = toWorld(mouseX, mouseY);

    // Check if clicked on node
    let clickedNode = null;
    for (const node of nodes) {
      if (node.contains(worldPos.x, worldPos.y)) {
        clickedNode = node;
        break;
      }
    }

    if (clickedNode) {
      draggingNode = clickedNode;
      dragOffsetX = worldPos.x - clickedNode.x;
      dragOffsetY = worldPos.y - clickedNode.y;
      selectedNode = clickedNode;
      selectedLink = null;
      draw();
      return;
    }

    // Check if clicked on link
    const clickedLink = findLinkAt(worldPos);
    if(clickedLink) {
      selectedLink = clickedLink;
      selectedNode = null;
      draw();
      return;
    }

    // Clicked empty space
    selectedNode = null;
    selectedLink = null;
    draw();
  });

  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    if (draggingNode) {
      const worldPos = toWorld(mouseX, mouseY);
      draggingNode.x = worldPos.x - dragOffsetX;
      draggingNode.y = worldPos.y - dragOffsetY;
      draw();
      return;
    }
    if (draggingCanvas) {
      offsetX = dragCanvasOffset.x + mouseX - dragCanvasStart.x;
      offsetY = dragCanvasOffset.y + mouseY - dragCanvasStart.y;
      draw();
    }
  });

  canvas.addEventListener('mouseup', e => {
    if(draggingNode) {
      draggingNode = null;
      saveHistory();
    }
    if(draggingCanvas) {
      draggingCanvas = false;
      canvas.style.cursor = 'grab';
    }
  });

  canvas.addEventListener('mouseleave', e => {
    if(draggingNode) {
      draggingNode = null;
      saveHistory();
    }
    if(draggingCanvas) {
      draggingCanvas = false;
      canvas.style.cursor = 'grab';
    }
  });

  canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const wheelDelta = e.deltaY < 0 ? 1.1 : 0.9;
    const worldBefore = toWorld(mouseX, mouseY);
    scale *= wheelDelta;
    scale = Math.min(Math.max(scale, 0.3), 3);
    const worldAfter = toWorld(mouseX, mouseY);
    offsetX += (worldAfter.x - worldBefore.x) * scale;
    offsetY += (worldAfter.y - worldBefore.y) * scale;
    draw();
  }, { passive: false });

  // Keyboard shortcuts
  canvas.addEventListener('keydown', e => {
    if (document.activeElement !== canvas) return;
    if (e.key === 'Delete' || e.key === 'Backspace') {
      if(selectedNode) {
        deleteNode(selectedNode);
        e.preventDefault();
      } else if(selectedLink) {
        deleteLink(selectedLink);
        e.preventDefault();
      }
    } else if ((e.key === 'z' || e.key === 'Z') && (e.ctrlKey || e.metaKey)) {
      if(e.shiftKey) redo();
      else undo();
      e.preventDefault();
    } else if ((e.key === 'y' || e.key === 'Y') && (e.ctrlKey || e.metaKey)) {
      redo();
      e.preventDefault();
    } else if (e.key === 'Enter' && selectedNode) {
      addChildNode(selectedNode);
      e.preventDefault();
    }
  });

  // Context menu on right click node
  canvas.addEventListener('contextmenu', e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const worldPos = toWorld(mouseX, mouseY);
    let clickedNode = null;
    for (const node of nodes) {
      if (node.contains(worldPos.x, worldPos.y)) {
        clickedNode = node;
        break;
      }
    }
    if (!clickedNode) {
      hideContextMenu();
      return;
    }
    selectedNode = clickedNode;
    selectedLink = null;
    draw();
    showContextMenu(e.clientX, e.clientY, [
      { label: 'Thêm con', action: () => addChildNode(selectedNode) },
      { label: 'Sửa nội dung', action: () => editNodeText(selectedNode) },
      { label: 'Xóa nút', action: () => deleteNode(selectedNode) },
      { label: 'Tạo liên kết...', action: () => startLinkCreation(selectedNode) },
    ]);
  });

  // Hide context menu if clicking elsewhere
  window.addEventListener('click', e => {
    if (e.target.closest('#contextMenu') === null) {
      hideContextMenu();
    }
  });

  // Show context menu
  function showContextMenu(x, y, items) {
    contextMenu.innerHTML = '';
    items.forEach(item => {
      const btn = document.createElement('button');
      btn.textContent = item.label;
      btn.onclick = () => {
        item.action();
        hideContextMenu();
      };
      contextMenu.appendChild(btn);
    });
    contextMenu.style.left = x + 'px';
    contextMenu.style.top = y + 'px';
    contextMenu.style.display = 'block';
  }
  function hideContextMenu() {
    contextMenu.style.display = 'none';
  }

  // Node operations
  function addRootNode() {
    const text = prompt('Nhập nội dung nút gốc:');
    if (!text) return;
    const center = toWorld(canvas.width/2, canvas.height/2);
    const id = Date.now().toString();
    nodes.push(new Node(id, text, center.x, center.y));
    saveHistory();
    draw();
  }
  function addChildNode(parentNode) {
    const text = prompt('Nhập nội dung nút con:');
    if (!text) return;
    const offset = 140;
    // Place child near parent
    const childX = parentNode.x + (Math.random() * 2 - 1) * offset;
    const childY = parentNode.y + offset;
    const id = Date.now().toString();
    const childNode = new Node(id, text, childX, childY);
    nodes.push(childNode);
    links.push(new Link(parentNode.id, id));
    saveHistory();
    draw();
  }
  function editNodeText(node) {
    const newText = prompt('Chỉnh sửa nội dung nút:', node.text);
    if (newText !== null) {
      node.text = newText.trim() || node.text;
      saveHistory();
      draw();
    }
  }
  function deleteNode(node) {
    nodes = nodes.filter(n => n.id !== node.id);
    links = links.filter(l => l.from !== node.id && l.to !== node.id);
    selectedNode = null;
    saveHistory();
    draw();
  }
  function deleteLink(link) {
    links = links.filter(l => l !== link);
    selectedLink = null;
    saveHistory();
    draw();
  }

  // Link creation via context menu
  let linkingFromNode = null;
  function startLinkCreation(fromNode) {
    linkingFromNode = fromNode;
    alert('Chọn nút đích để tạo liên kết (bấm vào node đó)');
  }
  canvas.addEventListener('click', e => {
    if (!linkingFromNode) return;
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const worldPos = toWorld(mouseX, mouseY);
    for (const node of nodes) {
      if (node.contains(worldPos.x, worldPos.y)) {
        if (node.id !== linkingFromNode.id) {
          // Add link if not exist
          if (!links.some(l => (l.from === linkingFromNode.id && l.to === node.id))) {
            links.push(new Link(linkingFromNode.id, node.id));
            saveHistory();
            draw();
          }
        }
        break;
      }
    }
    linkingFromNode = null;
  });

  // Find link near point (for selection)
  function findLinkAt(point) {
    const tolerance = 10 / scale;
    for (const link of links) {
      const fromNode = nodes.find(n => n.id === link.from);
      const toNode = nodes.find(n => n.id === link.to);
      if (!fromNode || !toNode) continue;
      if (pointNearBezier(point, fromNode, toNode, tolerance)) return link;
    }
    return null;
  }
  // Check if point near bezier curve
  function pointNearBezier(p, fromNode, toNode, tol) {
    // Approximate bezier with small segments and check distance
    const steps = 30;
    let prev = { x: fromNode.x, y: fromNode.y };
    for (let t = 0; t <= 1; t += 1 / steps) {
      const pt = cubicBezierPoint(fromNode, toNode, t);
      const dist = distancePointToSegment(p, prev, pt);
      if (dist < tol) return true;
      prev = pt;
    }
    return false;
  }
  function cubicBezierPoint(fromNode, toNode, t) {
    const dx = toNode.x - fromNode.x;
    const dy = toNode.y - fromNode.y;
    const cp1x = fromNode.x + dx * 0.3;
    const cp1y = fromNode.y;
    const cp2x = fromNode.x + dx * 0.7;
    const cp2y = toNode.y;

    const x = cubicBezier(t, fromNode.x, cp1x, cp2x, toNode.x);
    const y = cubicBezier(t, fromNode.y, cp1y, cp2y, toNode.y);
    return { x, y };
  }
  function cubicBezier(t, p0, p1, p2, p3) {
    const c = 3 * (p1 - p0);
    const b = 3 * (p2 - p1) - c;
    const a = p3 - p0 - c - b;
    return ((a * t + b) * t + c) * t + p0;
  }
  function distancePointToSegment(p, v, w) {
    const l2 = (v.x - w.x) * (v.x - w.x) + (v.y - w.y) * (v.y - w.y);
    if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
    let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    t = Math.max(0, Math.min(1, t));
    const proj = { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) };
    return Math.hypot(p.x - proj.x, p.y - proj.y);
  }

  // Export / Import JSON
  exportBtn.onclick = () => {
    const data = { nodes, links };
    exportArea.value = JSON.stringify(data, null, 2);
  };
  importBtn.onclick = () => {
    fileInput.click();
  };
  fileInput.addEventListener('change', e => {
    const file = fileInput.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const data = JSON.parse(reader.result);
        if (data.nodes && data.links) {
          nodes = data.nodes.map(n => Object.assign(new Node(), n));
          links = data.links.map(l => Object.assign(new Link(), l));
          selectedNode = null;
          selectedLink = null;
          saveHistory();
          draw();
          alert('Tải dữ liệu thành công!');
        } else {
          alert('File không hợp lệ!');
        }
      } catch {
        alert('Không thể đọc file!');
      }
    };
    reader.readAsText(file);
  });

  // Export PNG
  exportPngBtn.onclick = () => {
    const dataURL = canvas.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = dataURL;
    a.download = 'mindmap.png';
    a.click();
  };

  // Add root node button
  addNodeBtn.onclick = addRootNode;
  undoBtn.onclick = undo;
  redoBtn.onclick = redo;

  // Initial state save
  saveHistory();

  // Draw initial empty canvas
  draw();

  // Focus canvas for keyboard shortcuts
  canvas.tabIndex = 0;
  canvas.style.outline = 'none';

  // Helper: debounce function
  function debounce(func, wait) {
    let timeout;
    return function(...args) {
      clearTimeout(timeout);
      timeout = setTimeout(() => func.apply(this, args), wait);
    };
  }
})();
</script>

</body>
</html>
