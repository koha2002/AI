<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mindmap nâng cao - zoom, undo, xóa, layout, export</title>
<style>
  body { font-family: Arial, sans-serif; margin: 10px; }
  #toolbar {
    margin-bottom: 10px;
  }
  button {
    margin-right: 6px;
    margin-bottom: 6px;
  }
  #canvas {
    border: 1px solid #ccc;
    background: #fefefe;
    cursor: grab;
  }
  #exportArea {
    width: 100%;
    height: 100px;
    margin-top: 10px;
    font-family: monospace;
  }
</style>
</head>
<body>

<h2>Mindmap nâng cao</h2>

<div id="toolbar">
  <button id="addNodeBtn">Thêm nút</button>
  <button id="deleteNodeBtn" disabled>Xóa nút</button>
  <button id="deleteLinkBtn" disabled>Xóa liên kết</button>
  <button id="autoLayoutBtn">Tự động sắp xếp</button>
  <button id="undoBtn" disabled>Undo</button>
  <button id="redoBtn" disabled>Redo</button>
  <button id="exportBtn">Xuất dữ liệu JSON</button>
  <button id="importBtn">Tải dữ liệu JSON</button>
  <button id="exportPngBtn">Xuất ảnh PNG</button>
  <input type="file" id="fileInput" style="display:none" accept=".json" />
</div>

<canvas id="canvas" width="900" height="600"></canvas>
<textarea id="exportArea" placeholder="Dữ liệu JSON xuất ra sẽ hiện ở đây" readonly></textarea>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // Toolbar buttons
  const addNodeBtn = document.getElementById('addNodeBtn');
  const deleteNodeBtn = document.getElementById('deleteNodeBtn');
  const deleteLinkBtn = document.getElementById('deleteLinkBtn');
  const autoLayoutBtn = document.getElementById('autoLayoutBtn');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const exportBtn = document.getElementById('exportBtn');
  const importBtn = document.getElementById('importBtn');
  const exportPngBtn = document.getElementById('exportPngBtn');
  const fileInput = document.getElementById('fileInput');
  const exportArea = document.getElementById('exportArea');

  // Data structures
  let nodes = [];
  let links = [];

  // History stacks for undo/redo
  let history = [];
  let historyIndex = -1;

  // Viewport transform
  let offsetX = 0;
  let offsetY = 0;
  let scale = 1;

  // Interaction state
  let draggingNode = null;
  let dragOffsetX = 0;
  let dragOffsetY = 0;

  let draggingCanvas = false;
  let dragCanvasStartX = 0;
  let dragCanvasStartY = 0;
  let dragCanvasOffsetX = 0;
  let dragCanvasOffsetY = 0;

  let selectedNode = null;
  let selectedLink = null;
  let linkStartNode = null;

  // Constants
  const NODE_RADIUS = 40;

  // Classes
  class Node {
    constructor(id, text, x, y) {
      this.id = id;
      this.text = text;
      this.x = x;
      this.y = y;
      this.radius = NODE_RADIUS;
    }
    isPointInside(px, py) {
      const dx = px - this.x;
      const dy = py - this.y;
      return dx * dx + dy * dy <= this.radius * this.radius;
    }
  }

  function saveHistory() {
    // Save current state (deep clone)
    const state = {
      nodes: JSON.parse(JSON.stringify(nodes)),
      links: JSON.parse(JSON.stringify(links))
    };
    // Remove redo history if we add new action
    history = history.slice(0, historyIndex + 1);
    history.push(state);
    historyIndex++;
    updateUndoRedoButtons();
  }

  function undo() {
    if (historyIndex <= 0) return;
    historyIndex--;
    restoreState(history[historyIndex]);
    updateUndoRedoButtons();
  }

  function redo() {
    if (historyIndex >= history.length - 1) return;
    historyIndex++;
    restoreState(history[historyIndex]);
    updateUndoRedoButtons();
  }

  function restoreState(state) {
    nodes = JSON.parse(JSON.stringify(state.nodes));
    links = JSON.parse(JSON.stringify(state.links));
    selectedNode = null;
    selectedLink = null;
    draw();
  }

  function updateUndoRedoButtons() {
    undoBtn.disabled = historyIndex <= 0;
    redoBtn.disabled = historyIndex >= history.length - 1;
  }

  // Coordinate conversion (canvas to world and vice versa)
  function toWorld(x, y) {
    return {
      x: (x - offsetX) / scale,
      y: (y - offsetY) / scale
    };
  }

  function toScreen(x, y) {
    return {
      x: x * scale + offsetX,
      y: y * scale + offsetY
    };
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw links
    ctx.lineWidth = 2;
    links.forEach(link => {
      const from = nodes.find(n => n.id === link.from);
      const to = nodes.find(n => n.id === link.to);
      if (from && to) {
        const fromScreen = toScreen(from.x, from.y);
        const toScreenPos = toScreen(to.x, to.y);
        ctx.strokeStyle = (selectedLink === link) ? '#e74c3c' : '#555';
        ctx.beginPath();
        ctx.moveTo(fromScreen.x, fromScreen.y);
        ctx.lineTo(toScreenPos.x, toScreenPos.y);
        ctx.stroke();
      }
    });

    // Draw nodes
    nodes.forEach(node => {
      const screenPos = toScreen(node.x, node.y);
      ctx.beginPath();
      ctx.fillStyle = (node === selectedNode) ? '#ffec99' : '#fff';
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.shadowColor = 'rgba(0,0,0,0.15)';
      ctx.shadowBlur = 6;
      ctx.shadowOffsetX = 2;
      ctx.shadowOffsetY = 2;
      ctx.arc(screenPos.x, screenPos.y, node.radius * scale, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowColor = 'transparent';
      ctx.stroke();

      // Text
      ctx.fillStyle = '#000';
      ctx.font = `${14 * scale}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      wrapText(ctx, node.text, screenPos.x, screenPos.y, node.radius * 3 * scale, 18 * scale);
    });
  }

  // Wrap text for multi-line inside node
  function wrapText(context, text, x, y, maxWidth, lineHeight) {
    const words = text.split(' ');
    let line = '';
    const lines = [];
    for (let i = 0; i < words.length; i++) {
      const testLine = line + words[i] + ' ';
      const metrics = context.measureText(testLine);
      if (metrics.width > maxWidth && i > 0) {
        lines.push(line);
        line = words[i] + ' ';
      } else {
        line = testLine;
      }
    }
    lines.push(line);

    const totalHeight = lines.length * lineHeight;
    let startY = y - totalHeight / 2 + lineHeight / 2;

    for (let i = 0; i < lines.length; i++) {
      context.fillText(lines[i].trim(), x, startY + i * lineHeight);
    }
  }

  // Add node handler
  function addNode() {
    const text = prompt('Nhập nội dung cho nút:');
    if (!text) return;
    // Place node in center view
    const centerX = (canvas.width / 2 - offsetX) / scale;
    const centerY = (canvas.height / 2 - offsetY) / scale;
    const id = Date.now().toString();
    nodes.push(new Node(id, text, centerX, centerY));
    saveHistory();
    draw();
  }

  // Get node at screen coordinates
  function getNodeAtPos(screenX, screenY) {
    const worldPos = toWorld(screenX, screenY);
    return nodes.find(node => {
      const dx = worldPos.x - node.x;
      const dy = worldPos.y - node.y;
      return dx * dx + dy * dy <= (node.radius * node.radius);
    });
  }

  // Get link near point (within certain tolerance)
  function getLinkAtPos(screenX, screenY) {
    const worldPos = toWorld(screenX, screenY);
    const tolerance = 10 / scale;
    for (const link of links) {
      const from = nodes.find(n => n.id === link.from);
      const to = nodes.find(n => n.id === link.to);
      if (!from || !to) continue;
      if (pointNearLine(worldPos, from, to, tolerance)) {
        return link;
      }
    }
    return null;
  }

  function pointNearLine(p, a, b, tol) {
    // Check if point p is within tol distance from segment a-b
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const lengthSq = dx * dx + dy * dy;
    if (lengthSq === 0) return false;
    let t = ((p.x - a.x) * dx + (p.y - a.y) * dy) / lengthSq;
    t = Math.max(0, Math.min(1, t));
    const projX = a.x + t * dx;
    const projY = a.y + t * dy;
    const distSq = (p.x - projX) ** 2 + (p.y - projY) ** 2;
    return distSq <= tol * tol;
  }

  // Mouse interaction handlers
  canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
      // Middle click or Shift + Left click: drag canvas
      draggingCanvas = true;
      dragCanvasStartX = x;
      dragCanvasStartY = y;
      dragCanvasOffsetX = offsetX;
      dragCanvasOffsetY = offsetY;
      canvas.style.cursor = 'grabbing';
      return;
    }

    // Ctrl + click to create links between nodes
    if (e.ctrlKey && e.button === 0) {
      const node = getNodeAtPos(x, y);
      if (!node) return;
      if (!linkStartNode) {
        linkStartNode = node;
        alert('Chọn nút thứ hai (Ctrl + click) để nối liên kết');
      } else if (linkStartNode.id !== node.id) {
        // Check if link exists
        const exists = links.some(l => 
          (l.from === linkStartNode.id && l.to === node.id) ||
          (l.from === node.id && l.to === linkStartNode.id)
        );
        if (!exists) {
          links.push({ from: linkStartNode.id, to: node.id });
          saveHistory();
        }
        linkStartNode = null;
        draw();
      }
      return;
    }

    // Check if clicked on a node
    const node = getNodeAtPos(x, y);
    if (node) {
      draggingNode = node;
      selectedNode = node;
      selectedLink = null;
      dragOffsetX = toWorld(x, y).x - node.x;
      dragOffsetY = toWorld(x, y).y - node.y;
      deleteNodeBtn.disabled = false;
      deleteLinkBtn.disabled = true;
      draw();
      return;
    }

    // Check if clicked on a link
    const link = getLinkAtPos(x, y);
    if (link) {
      selectedLink = link;
      selectedNode = null;
      deleteLinkBtn.disabled = false;
      deleteNodeBtn.disabled = true;
      draw();
      return;
    }

    // Clicked empty space
    selectedNode = null;
    selectedLink = null;
    deleteNodeBtn.disabled = true;
    deleteLinkBtn.disabled = true;
    draw();
  });

  canvas.addEventListener('mousemove', (e) => {
    if (draggingNode) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const worldPos = toWorld(x, y);
      draggingNode.x = worldPos.x - dragOffsetX;
      draggingNode.y = worldPos.y - dragOffsetY;
      draw();
    } else if (draggingCanvas) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      offsetX = dragCanvasOffsetX + (x - dragCanvasStartX);
      offsetY = dragCanvasOffsetY + (y - dragCanvasStartY);
      draw();
    }
  });

  canvas.addEventListener('mouseup', (e) => {
    if (draggingNode) {
      draggingNode = null;
      saveHistory();
    }
    if (draggingCanvas) {
      draggingCanvas = false;
      canvas.style.cursor = 'grab';
    }
  });

  canvas.addEventListener('mouseleave', () => {
    if (draggingNode) {
      draggingNode = null;
      saveHistory();
    }
    if (draggingCanvas) {
      draggingCanvas = false;
      canvas.style.cursor = 'grab';
    }
  });

  // Zoom with mouse wheel
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const wheel = e.deltaY < 0 ? 1.1 : 0.9;

    // Zoom relative to mouse pointer
    const worldPosBefore = toWorld(mouseX, mouseY);
    scale *= wheel;
    scale = Math.min(Math.max(scale, 0.2), 3);
    const worldPosAfter = toWorld(mouseX, mouseY);

    // Adjust offset to keep mouse position stable
    offsetX += (worldPosAfter.x - worldPosBefore.x) * scale;
    offsetY += (worldPosAfter.y - worldPosBefore.y) * scale;

    draw();
  });

  // Double click to edit node text
  canvas.addEventListener('dblclick', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const node = getNodeAtPos(x, y);
    if (!node) return;
    const newText = prompt('Chỉnh sửa nội dung nút:', node.text);
    if (newText !== null) {
      node.text = newText.trim() || node.text;
      saveHistory();
      draw();
    }
  });

  // Toolbar buttons events
  addNodeBtn.onclick = addNode;

  deleteNodeBtn.onclick = () => {
    if (!selectedNode) return;
    // Remove related links
    links = links.filter(l => l.from !== selectedNode.id && l.to !== selectedNode.id);
    nodes = nodes.filter(n => n.id !== selectedNode.id);
    selectedNode = null;
    deleteNodeBtn.disabled = true;
    saveHistory();
    draw();
  };

  deleteLinkBtn.onclick = () => {
    if (!selectedLink) return;
    links = links.filter(l => l !== selectedLink);
    selectedLink = null;
    deleteLinkBtn.disabled = true;
    saveHistory();
    draw();
  };

  undoBtn.onclick = undo;
  redoBtn.onclick = redo;

  exportBtn.onclick = () => {
    const data = { nodes, links };
    const jsonStr = JSON.stringify(data, null, 2);
    exportArea.value = jsonStr;
  };

  importBtn.onclick = () => {
    fileInput.click();
  };

  fileInput.onchange = e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = event => {
      try {
        const data = JSON.parse(event.target.result);
        if (data.nodes && data.links) {
          nodes = data.nodes.map(n => new Node(n.id, n.text, n.x, n.y));
          links = data.links;
          selectedNode = null;
          selectedLink = null;
          offsetX = 0;
          offsetY = 0;
          scale = 1;
          saveHistory();
          draw();
          alert('Dữ liệu đã được tải thành công!');
        } else {
          alert('File JSON không hợp lệ!');
        }
      } catch (err) {
        alert('Lỗi đọc file JSON!');
      }
    };
    reader.readAsText(file);
    fileInput.value = '';
  };

  exportPngBtn.onclick = () => {
    // Temporary scale to 2x for better resolution
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = canvas.width * 2;
    tempCanvas.height = canvas.height * 2;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.scale(2, 2);
    // Copy current drawing
    // Use the same draw function but draw to tempCtx with adjusted scale and offset
    tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);

    // Draw links
    tempCtx.lineWidth = 2;
    links.forEach(link => {
      const from = nodes.find(n => n.id === link.from);
      const to = nodes.find(n => n.id === link.to);
      if (from && to) {
        const fromScreen = {
          x: from.x * scale + offsetX,
          y: from.y * scale + offsetY
        };
        const toScreenPos = {
          x: to.x * scale + offsetX,
          y: to.y * scale + offsetY
        };
        tempCtx.strokeStyle = '#555';
        tempCtx.beginPath();
        tempCtx.moveTo(fromScreen.x, fromScreen.y);
        tempCtx.lineTo(toScreenPos.x, toScreenPos.y);
        tempCtx.stroke();
      }
    });

    // Draw nodes
    nodes.forEach(node => {
      const screenPos = {
        x: node.x * scale + offsetX,
        y: node.y * scale + offsetY
      };
      tempCtx.beginPath();
      tempCtx.fillStyle = '#fff';
      tempCtx.strokeStyle = '#333';
      tempCtx.lineWidth = 2;
      tempCtx.shadowColor = 'rgba(0,0,0,0.15)';
      tempCtx.shadowBlur = 6;
      tempCtx.shadowOffsetX = 2;
      tempCtx.shadowOffsetY = 2;
      tempCtx.arc(screenPos.x, screenPos.y, node.radius * scale, 0, Math.PI * 2);
      tempCtx.fill();
      tempCtx.shadowColor = 'transparent';
      tempCtx.stroke();

      // Text
      tempCtx.fillStyle = '#000';
      tempCtx.font = `${14 * scale}px Arial`;
      tempCtx.textAlign = 'center';
      tempCtx.textBaseline = 'middle';
      wrapText(tempCtx, node.text, screenPos.x, screenPos.y, node.radius * 3 * scale, 18 * scale);
    });

    // Generate PNG image
    const dataURL = tempCanvas.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = dataURL;
    a.download = 'mindmap.png';
    a.click();
  };

  // Simple auto-layout function - arrange nodes in tree layout
  // Root node is one with no incoming links
  function autoLayout() {
    // Find roots (nodes with no incoming links)
    const incoming = {};
    nodes.forEach(n => incoming[n.id] = 0);
    links.forEach(l => incoming[l.to] = (incoming[l.to] || 0) + 1);
    const roots = nodes.filter(n => incoming[n.id] === 0);
    if (roots.length === 0) {
      alert('Không tìm thấy nút gốc để tự động sắp xếp!');
      return;
    }
    // For simplicity, layout each root subtree vertically
    const levelGap = 120;
    const siblingGap = 150;

    let currentX = 0;

    function layoutSubtree(node, depth) {
      node.y = depth * levelGap;
      const children = links.filter(l => l.from === node.id).map(l => nodes.find(n => n.id === l.to));
      if (children.length === 0) {
        node.x = currentX;
        currentX += siblingGap;
        return [node.x, node.x];
      }
      let minX = Infinity, maxX = -Infinity;
      children.forEach(child => {
        const [childMin, childMax] = layoutSubtree(child, depth + 1);
        minX = Math.min(minX, childMin);
        maxX = Math.max(maxX, childMax);
      });
      node.x = (minX + maxX) / 2;
      return [minX, maxX];
    }

    roots.forEach(root => layoutSubtree(root, 0));

    saveHistory();
    draw();
  }

  autoLayoutBtn.onclick = autoLayout;

  // Initialize history
  saveHistory();

  // Initial draw
  draw();

  // Instructions in console
  console.log('Hướng dẫn Mindmap nâng cao:');
  console.log('- Thêm nút: nút "Thêm nút"');
  console.log('- Kéo thả nút để di chuyển');
  console.log('- Ctrl + click hai nút để nối liên kết');
  console.log('- Chọn nút hoặc liên kết rồi nhấn "Xóa" tương ứng để xoá');
  console.log('- Shift + click hoặc giữa click và kéo để di chuyển canvas');
  console.log('- Cuộn chuột để zoom (phóng to/thu nhỏ)');
  console.log('- Double click nút để sửa text');
  console.log('- Undo/Redo các thao tác');
  console.log('- Tự động sắp xếp theo cây');
  console.log('- Xuất JSON và tải JSON để lưu/tiếp tục chỉnh sửa');
  console.log('- Xuất ảnh PNG');

})();
</script>

</body>
</html>
